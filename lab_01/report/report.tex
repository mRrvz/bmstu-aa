\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
%\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 

% Для листинга кода:
\lstset{ %
language=python,                 % выбор языка для подсветки (здесь это С)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}

% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\begin{filecontents}{LevR.dat}
1 5928
2 16865
3 62333
4 372661
5 1909255
6 9065189
7 45325069
\end{filecontents}

\begin{filecontents}{LevT.dat}
1 3724258
2 7224736
3 12123365
4 16940041
5 23402008
6 32328258
7 30166031
\end{filecontents}

\begin{filecontents}{DamLevR.dat}
1 7456
2 21845
3 105445
4 407763
5 1966658
6 11002094
7 51219656
\end{filecontents}

\begin{filecontents}{DamLevT.dat}
1 4367560
2 8286833
3 12852145
4 18585284
5 24103230
6 27935583
7 30567571
\end{filecontents}


\begin{document}
%\def\chaptername{} % убирает "Глава"
\thispagestyle{empty}
\begin{titlepage}
	\noindent \begin{minipage}{0.15\textwidth}
	\includegraphics[width=\linewidth]{b_logo}
	\end{minipage}
	\noindent\begin{minipage}{0.9\textwidth}\centering
		\textbf{Министерство науки и высшего образования Российской Федерации}\\
		\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
		\textbf{~~~«Московский государственный технический университет имени Н.Э.~Баумана}\\
		\textbf{(национальный исследовательский университет)»}\\
		\textbf{(МГТУ им. Н.Э.~Баумана)}
	\end{minipage}
	
	\noindent\rule{18cm}{3pt}
	\newline\newline
	\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»}}$ \newline\newline
	\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»}}$\newline\newline\newline\newline\newline
	
	
	\begin{center}
		\noindent\begin{minipage}{1.3\textwidth}\centering
			\Large\textbf{  Лабораторная работа № 1}\newline
			\textbf{по дисциплине "Анализ алгоритмов"}\newline\newline
		\end{minipage}
	\end{center}
	
	\noindent\textbf{Тема} $\underline{\text{Расстояние Левенштейна}}$\newline\newline
	\noindent\textbf{Студент} $\underline{\text{Романов А.В.}}$\newline\newline
	\noindent\textbf{Группа} $\underline{\text{ИУ7-53Б}}$\newline\newline
	\noindent\textbf{Оценка (баллы)} $\underline{\text{~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
	\noindent\textbf{Преподаватели} $\underline{\text{Волкова Л.Л., Строганов Ю.В.}}$\newline\newline\newline
	
	\begin{center}
		\vfill
		Москва~---~\the\year
		~г.
	\end{center}
\end{titlepage}


\tableofcontents

\newpage
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}
\textbf{Расстояние Левенштейна} - минимальное количество операций вставки одного символа, удаления одного символа и замены одного символа на другой, необходимых для превращения одной строки в другую.\newline

Расстояние Левенштейна применяется в теории информации и компьютерной лингвистике для:

\begin{itemize}
	\item исправления ошибок в слове
	\item сравнения текстовых файлов утилитой diff
	\item в биоинформатике для сравнения генов, хромосом и белков
\end{itemize}

Целью данной лабораторной работы: 
\begin{enumerate}
	\item Изучение метода динамического программирования на материале алгоритмов Левенштейна и Дамерау-Левенштейна.
	\item Оценка реализаций алгоритмов Левенштейна и Дамерау-Левенштейна.
\end{enumerate}

Задачи данной лабораторной работы:
\begin{enumerate}
  	\item Изучение алгоритмов Левенштейна и Дамерау-Левенштейна;
	\item Применение метода динамического программирования для матричной реализации указанных алгоритмов; 
	\item Получение практических навыков реализации указанных алгоритмов: матричные и рекурсивные версии; 
	\item Сравнительный анализ линейной и рекурсивной реализаций выбранного алгоритма определения расстояния между строками по затрачиваемым ресурсам (времени и памяти); 
	\item Экспериментальное подтверждение различий во временнóй эффективности рекурсивной и
нерекурсивной реализаций выбранного алгоритма; 
	\item Описание и обоснование полученных результатов в отчете о выполненной лабораторной
работе, выполненного как расчётно-пояснительная записка к работе. 
\end{enumerate}


\chapter{Аналитическая часть}
Задача по нахождению расстояния Левенштейна заключается в поиске минимального количества операций вставки/удаления/замены для превращения одной строки в другую.\newline

При нахождении расстояния Дамерау — Левенштейна добавляется операция транспозиции (перестановки соседних символов).  \newline
 
\textbf{Обозначение операций} 
\begin{enumerate}
  	\item D (delete) -- удалить,
	\item I (insert) -- вставить,
	\item R (replace) -- заменить,
	\item M (match) -- совпадение символов.
\end{enumerate}

Пусть $S_{1}$ и $S_{2}$ — две строки (длиной M и N соответственно) над некоторым алфавитом, тогда расстояние Левенштейна можно подсчитать по следующей рекуррентной формуле:

\begin{displaymath}
D(i,j) = \left\{ \begin{array}{ll}
 0, & \textrm{$i = 0, j = 0$}\\
 i, & \textrm{$j = 0, i > 0$}\\
 j, & \textrm{$i = 0, j > 0$}\\
min(\\
D(i,j-1)+1,\\
D(i-1, j) +1, &\textrm{$j>0, i>0$}\\
D(i-1, j-1) + m(S_{1}[i], S_{2}[j])\\
),
  \end{array} \right.
\end{displaymath}

где $m(a,b)$ равна нулю, если $a=b$ и единице в противном случае; $min\{\,a,b,c\}$ возвращает наименьший из аргументов.\newline

Расстояние Дамерау-Левенштейна вычисляется по следующей рекуррентной формуле:
		    
		     \[ D(i, j) =  \left\{
			\begin{aligned}
				&0, && i = 0, j = 0\\
		    	&i, && i > 0, j = 0\\
		    	&j, && i = 0, j > 0\\		    	
		    	&min \left\{
				\begin{aligned}
					&D(i, j - 1) + 1,\\
		            &D(i - 1, j) + 1,\\
		            &D(i - 1, j - 1) + m(S_{1}[i], S_{2}[i]),\\
		            &D(i - 2, j - 2) + m(S_{1}[i], S_{2}[i]),\\
		        \end{aligned} \right.
		        && 
				\begin{aligned}
					&\text{ если } i, j > 0 \\
		            & \text{ и } S_{1}[i] = S_{2}[j - 1] \\
		            & \text{ и } S_{1}[i - 1] =  S_{2}[j] \\
		        \end{aligned} \\ 
		        &min \left\{
		        \begin{aligned}
		            &D(i, j - 1) + 1,\\
		            &D(i - 1, j) + 1, \\
		            &D(i - 1, j - 1) + m(S_{1}[i], S_{2}[i]),\\
		        \end{aligned} \right.  &&\text{ иначе}
			\end{aligned} \right.
			\]	
	    
\section{Вывод}
	В данном разделе были рассмотрены алгоритмы нахождения расстояния Левенштейна и Дамерау-Левенштейна, который является модификаций первого, учитывающего возможность перестановки соседних символов. 




\chapter{Конструкторская часть}
\textbf{Требования к вводу:}
\begin{enumerate}
  	\item На вход подаются две строки
\end{enumerate}
\textbf{Требования к программе:}
\begin{enumerate}
  	\item ПО должно выводить полученное расстояние и вспомогательные матрицы;
  	\item ПО должно выводить потраченную память и время;
\end{enumerate}
\section{Схемы алгоритмов}
В данной части будут рассмотрены схемы алгоритмов.

\begin{figure}[h]
\centering
%\includegraphics[width=0.75\linewidth]{RecLev.png}
\caption{Схема рекурсивного алгоритма нахождения расстояния Левенштейна}
\label{fig:mpr}
\end{figure}


\begin{figure}[h]
\centering
%\includegraphics[width=0.6\linewidth]{MatrixL.jpg}
\caption{Схема матричного алгоритма нахождения расстояния Левенштейна}
\label{fig:mpr}
\end{figure}


\begin{figure}[h]
\centering
%\includegraphics[width=0.75\linewidth]{RecDL.png}
\caption{Схема рекурсивного алгоритма нахождения расстояния Дамерау-Левенштейна}
\label{fig:mpr}
\end{figure}

\begin{figure}[h]
\centering
%\includegraphics[width=0.75\linewidth]{MatrixDL.jpg}
\caption{Схема матричного алгоритма нахождения расстояния Дамерау-Левенштейна}
\label{fig:mpr}
\end{figure}


\chapter{Технологическая часть}
\section{Выбор ЯП}
Для реализации программы нахождения расстояние Левенштейна я выбрал язык программирования Haskell.Так как Haskell использует ленивые вычисления, рекурсивные алгоритмы крайне неэффективы: на строках длинной более 10 уже полностью заполняется оперативная память.

\section{Реализация алгоритма}

\begin{lstlisting}[label=some-code,caption=Функция нахождения расстояния Левенштейна рекурсивно]
levenshteinRecursion :: String -> String -> (Distance, Depth)
levenshteinRecursion s1 s2 = _recursion s1 s2 0
	where _recursion s1 "" n = (length s1, n)
		_recursion "" s2 n = (length s2, n)
		_recursion s1 s2 n = (score, depth) where
		(insert, curr1) = _recursion (init s1) s2 (n + 1)
		(delete, curr2) = _recursion s1 (init s2) (n + 1)
		(replace, curr3) = _recursion (init s1) (init s2) (n + 1)

		match = if last s1 == last s2 then 0 else 1
		score = min3 (insert + 1) (delete + 1) (replace + match)
		depth = max3 curr1 curr2 curr3
\end{lstlisting}
\clearpage

\begin{lstlisting}[label=some-code,caption=Функция нахождения расстояние Левенштейна рекурсивно с мемоизацией]
levenshteinMemoized :: String -> String -> (Distance, Depth)
levenshteinMemoized s1 s2 = _memoized s1 s2 matrix 0
	where matrix = fromList (length s1 + 1) (length s2 + 1) $ repeat (-1) 
		_memoized s1 "" _ n = (length s1, n)
		_memoized "" s2 _ n = (length s2, n)
		_memoized s1 s2 mtr n = (score, depth) where
		score = min3 (insert + 1) (delete + 1) (replace + match)
		memoized = (getElem (length s1) (length s2) mtr, n + 1)
		new_mtr = setElem score (length s1, length s2) mtr 

		(insert, curr1) = if fst memoized == -1 then _memoized (init s1) s2 new_mtr (n + 1)
			else memoized
		(delete, curr2) = if fst memoized == -1 then _memoized s1 (init s2) new_mtr (n + 1)
			else memoized
		(replace, curr3) = if fst memoized == -1 then _memoized (init s1) (init s2) new_mtr (n + 1)
			else memoized

		match = if last s1 == last s2 then 0 else 1
		depth = max3 curr1 curr2 curr3
\end{lstlisting}

\begin{lstlisting}[label=some-code,caption=Функция нахождения расстояния Левенштейна итеративно]
levenshteinIterative :: String -> String -> Matrix Int
levenshteinIterative s1 s2 = fromLists $ reverse $ foldl
	(\mtr i -> if head mtr == [] then [[0..length s1]] else calcRow mtr i : mtr) [[]] [0..length s2]
	where calcRow mtr i = foldl (\row j ->
			row ++ if length row == 0 then [length mtr] else [
				min3 (last row + 1) (head mtr !! j + 1) $ head mtr !! (j - 1) +
					if s1 !! (j - 1) == s2 !! (i - 1) then 0 else 1]
			) [] [0..length s1]
\end{lstlisting}


\begin{lstlisting}[label=some-code,caption=Функция нахождения расстояния Дамерау-Левенштейна матрично]
damerauLevenshtein :: String -> String -> Matrix Int
damerauLevenshtein s1 s2 = fromLists $ reverse $ foldl
	(\mtr i -> if head mtr == [] then [[0..length s1]] else calcRow mtr i : mtr) [[]] [0..length s2]
	where cell mtr row i j = min3 (last row + 1) (head mtr !! j + 1) $ head mtr !! (j - 1) +
			if s1 !! (j - 1) == s2 !! (i - 1) then 0 else 1
			transposition i j = i > 1 && j > 1 && s1 !! (j - 1) == s2 !! (i - 2) && s1 !! (j - 2) == s2 !! (i - 1)
			calcRow mtr i = foldl (\row j -> row ++ [
				if length row == 0 then length mtr
				else if transposition i j then min (cell mtr row i j) (((head $ tail mtr) !! i - 2) + 1)
				else cell mtr row i j]
			) [] [0..length s1]
\end{lstlisting}


\chapter{Исследовательская часть}

\section{Сравнительный анализ на основе замеров времени работы алгоритмов}

Замеры времени работы каждого из алгоритмов.


\begin{table} [h!]
\caption{Время работы алгоритмов (в наносек)}
	\begin{tabular}{|c c c c c|} 
 	\hline
	len & Lev(R) & Lev(MR) & Lev(I) & DamLev(I) \\ [0.8ex] 
 	\hline\hline
 	10 & 5928 & 3724258 & 7456 & 4367560\\
 	\hline
 	20 & 16865 & 7224736 & 21854 & 8286833\\
 	\hline
	30 & 62333 & 12123365 & 105445 & 12852145\\
	\hline
	50 & 372661 & 16940041 & 407763 & 18585284\\
	\hline
	100 & 1909255 & 23402008 & 1966658 & 24103230\\
	\hline
	200 & 9065189 & 32328258 & 11002094 & 27935583\\
	\hline
	\end{tabular}
\end{table}

\par
выват..
%Наиболее эффективными по времени при маленькой длине слова являются рекурсивные реализации алгоритмов, но как только увеличивается длина слова, их эффективность резко снижается, что обусловлено большим количеством повторных рассчетов. Время работы алгоритма, использующего матрицу, намного меньше благодаря тому, что в нем требуется только (m + 1)*(n + 1) операций заполнения ячейки матрицы. Также установлено, что алгоритм ДамерауЛевенштейна работает немного дольше алгоритма Левенштейна, т.к. в нем добавлены дополнительные проверки, однако алгоритмы сравнимы по временной эффективности.

\section{Тестовые данные}

\par
%Проведем тестирование программы. В столбцах "Ожидаемый результат" и "Полученный результат" 4 числа соответсвуют рекурсивному алгоритму нахождения расстояния Левенштейна, матричному алгоритму нахождению расстоянию Левенштейна, рекурсивному алгоритму расстояния Дамерау-Левенштейна, матричному алгоритму нахождения расстояние Дамерау-Левенштейна.

\begin{table} [h!]
\caption{Таблица тестовых данных}
	\begin{tabular}{|c c c c c|} 
 	\hline
	№ & Первое слово & Второе слово & Ожидаемый результат & Полученный результат \\ [0.8ex] 
 	\hline\hline
 	1 &  &  & 0 0 0 0 & 0 0 0 0\\
 	\hline
 	2 & kot & skat & 2 2 2 2 & 2 2 2 2\\
 	\hline
	3 & kate & ktae & 2 2 1 1 & 2 2 1 1\\
	\hline
	4 & abacaba & aabcaab & 4 4 2 2 & 4 4 2 2\\
	\hline
	5 & sobaka & sboku & 3 3 3 3 & 3 3 3 3\\
	\hline
	6 & qwerty & queue & 4 4 4 4 & 4 4 4 4\\
	\hline
	7 & apple & aplpe & 2 2 1 1  & 2 2 1 1\\
	\hline
	8 &  & cat & 3 3 3 3 & 3 3 3 3\\
	\hline
	9 & parallels &  & 9 9 9 9 & 9 9 9 9\\
	\hline
	10 & bmstu & utsmb & 4 4 4 4 & 4 4 4 4\\
	\hline
	\end{tabular}
\end{table}



\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}
Был изучен метод динамического программирования на материале алгоритмов Левенштейна и Дамерау-Левенштейна.
Также изучены алгоритмы Левенштейна и Дамерау-Левенштейна нахождения расстояния между строками, получены практические навыки раелизации указанных алгоритмов
в матричной  и рекурсивных версиях. 

Экспериментально было подтверждено различие во временной эффективности рекурсивной и нерекурсивной реализаций выбранного алгоритма определения расстояния между строками при помощи разработаного программного обеспечения на материале замеров процессорного времени выполнения реализации на варьирующихся длинах строк. 

В результате исследований я пришла к выводу, что матричная реализация данных алгоритмов заметно выигрывает по времени при росте длины строк, следовательно более применима в реальных проектах.


\end{document}